# 引用与指针

| 引用         | 指针         |
| ------------ | ------------ |
| 必须初始化   | 可以不初始化 |
| 不能为空     | 可以为空     |
| 不能更换目标 | 可以更换目标 |



> 我们在定义一个引用的时候必须为其指定一个初始值，但是指针却不需要。

```c++
int &a;	//error!没有初始化引用
int *b;	//ok,但b为野指针，使用时小心
```

> 由于引用不能为空，所以我们在使用引用的时候不需要测试其合法性，而在使用指针的时候需要首先判断指针是否为空指针，否则可能会引起程序崩溃。

```c++
void test_b(int* p)
{
    if(p != nullptr)
        *p = 3;
    return;
}
```

> 指针可以随时改变指向，但是引用只能指向初始化时指向的对象，无法改变。

```c++
int a = 1;
int b = 3;

int& r = a;	// 初始化引用r指向a
int* p = &b;	// 初始化引用p指向b

r = b;	// 引用r还是指向a，但是a的值变成了b
p = &b;	// 指针p指向了b
```



****

## 引用

### 左值引用

- 常规引用，一般表示对象的身份。

****

### 右值引用

- 右值引用就是必须绑定到右值（一个临时对象、将要销毁的对象）的引用，一般表示对象的值。

- 右值引用可实现转移语义（`Move Sementics`）和精确传递（`Perfect Forwarding`），它的主要目的有两个方面：
  - 消除两个对象交互时不必要的对象拷贝，节省运算存储资源，提高效率。
  - 能够更简洁明确地定义泛型函数。

****

### 引用折叠

- `X& &`、`X& &&`、`X&& &` 可折叠成 `X&`
- `X&& &&` 可折叠成 `X&&`

> C++的引用在减少了程序员自由度的同时提升了内存操作的安全性和语义的优美性。



#### 引用型参数

- 一般我们使用`const reference`参数作为只读形参，这种情况下既可以避免参数拷贝还可以获得与传值参数一样的调用方式。

```c++
void test(const vector<int> & vec){}
```



#### 引用型返回值

- C++提供了重载运算符的功能，我们在重载某些操作符的时候，使用引用型返回值可以获得跟该操作符原来语法相同的调用方式，保持了操作符语义的一致性。

****

## 引用和指针的性能差距

- C++编译器在编译程序的时候将**指针和引用编译成了完全一样的机器码**。所以C++中的引用只是C++对指针操作的一个“语法糖”，在底层实现时C++编译器实现这两种操作的方法完全相同。