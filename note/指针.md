# Pointers

- 变量已被解释为计算机内存中的位置，可以通过其标识符（其名称）进行访问。这样，程序无需关心内存中数据的物理地址；它仅在需要引用变量时使用标识符。

- 声明变量后，将存储其值所需的存储器分配给存储器中的特定位置（其存储器地址）。

- 通常，C ++程序不会主动决定存储其变量的确切内存地址。幸运的是，该任务留给了程序运行的环境-- 通常，一个操作系统会在运行时决定特定的内存位置。



## 地址运算符(&)

- 变量的地址可以通过在变量名前加上与号（`&`）来获得，这称为*地址运算符*。例如：

```c++
foo = &myvar;
```

- 这会将变量的地址分配`myvar`给`foo`; 通过在变量名前面`myvar`加上*地址运算符*（`&`），我们不再将变量本身的内容分配给`foo`，而是将其地址分配给`foo`。

## 引用操作符(*)

- 存储另一个变量地址的变量称为*指针*。指针被称为“指向”其存储地址的变量。

- 指针的一个有趣的特性是它们可用于直接访问它们指向的变量。这是通过在指针名称前面加上引用运算符（`*`）来完成的。运算符本身可以理解为“所指向的值”。

```c++
baz = *foo;
```



*注意包括或不包括*解引用运算符*的区别：*

```c++
baz = foo;	//baz的值为地址
baz = *foo;	//baz的值是foo地址所指向的值
```



- 因此，引用和取消引用运算符是互补的：
  - `&`是运算符的地址，可以简单地读作“地址”
  - `*`是取消引用运算符，可以理解为“由...指向的值”



## 声明指针

- 由于指针具有直接引用其指向的值的能力，因此指针在指向一个`char`时与指向一个`int`或一个`float`时具有不同的属性。为此，指针的声明需要包括指针将要指向的数据类型。

```c++
tpye * name;
```

- 其中`type`是指针指向的数据类型。该类型不是指针本身的类型，而是指针所指向的数据的类型。例如:

```c++
int * num;
float * sum;
```



**<u>请注意，星号（在声明指针时使用）仅表示它是一个指针（它是其类型复合说明符的一部分），并且不应与之前提到的引用运算符相混淆，但也应使用星号（`*  `）进行编写。它们只是两个用相同符号表示的不同事物。</u>**

###### 

- 注意：声明一行声明多个指针是要都在指针前加`*`，例如：

```c++
int * p1, * p2;
```

- 如果使用以下方式声明指针的话，会出现`p1`确实是类型`int*`，但`p2`会是类型`int`。

```c++
int * p1, p2;
```



- 指针和数组支持相同的操作集，两者的含义相同。主要区别在于可以为指针分配新的地址，而不能为数组分配新的地址。



- 在关于数组的章节中，方括号（`[]`）被解释为指定数组元素的索引。好吧，事实上，这些括号是一个解引用运算符，称为偏移(`offset`)运算符。他们像引用一样取消引用所跟随的变量`*`，但也将括号之间的数字添加到要取消引用的地址中。例如：

```c++
a[5] = 0;	//a[偏移5] = 0
*(a+5) = 0;	//指向(a+5) = 0
```

- 这两个表达式是等效且有效的，不仅`a`是指针，而且`a`是数组。请记住，如果是数组，则其名称可以像指向其第一个元素的指针一样使用。





## 指针初始化

- 指针可以在定义它们的那一刻初始化为指向特定位置：

```c++
int myvar;
int * myptr = &myvar;
```

- 指针可以初始化为变量的地址（例如上述情况），也可以初始化为另一个指针（或数组）的值：

```c++
int myvar;
int * foo = &myvar;
int * bar = foo;
```



## 指针运算

- 在指针上进行算术运算与在常规整数类型上进行算术运算有些不同。首先，**只允许加法和减法运算**



- 解引用运算符与增量运算符的前缀和后缀版本的四种可能的组合（同样适用于减量运算符）：

```c++
*p++;	//与*(p++)相似
*++p;	//与*(++p)相似
++*p;	//与++(*p)相似
(*p)++;	//反引用指针，并在它所指向的值后加1
```



- 实例：

```c++
*p++ = *q++;
```

- 大致相当于：

```c++
*p = *q;
++p;
++q;
```



## 指针和常量

- 指针可用于通过变量的地址访问变量，这种访问可能包括修改指向的值。但是也可以声明可以访问指向的值的指针，但不能修改它。为此，只要将指针指向的类型限定为即可`const`。

```c++
int x;
int y = 10;
const int * p = &y;
x = *p;	//成功：读取p
*p = x;	//失败：修改p，它是常量限定的
```



```c++
const int * p;	//指向常量int类型的非常量指针
int * const p;	//指向非常量int类型的常量指针
const int * const p;	//指向常量int类型的常量指针
```



- `const`限定符可以位于指针类型之前或之后，其含义完全相同

```c++
const int * p;
int const * p;
```



## 指针和字符串

```c++
const char * name = string;
```

- :ballot_box_with_check:`name`：变量名
- :ballot_box_with_check:`string`：字符串



- 例如：

```c++
const char * foo = "hello";
```



- 指针`foo`指向一个字符序列。并且由于指针和数组在表达式中的行为本质上相同，`foo`因此可以使用以空终止字符序列的数组相同的方式访问字符。例如：

```c++
*(foo+4);
foo[4]
```



## 指向指针的指针

- C ++允许使用指向指针的指针，而这些指针又指向数据（甚至指向其他指针）。该语法仅`*`在指针的声明中为每个间接级别要求一个`*`：

```c++
char a;
char * b;
char ** c;
a = 'z';
b = &a;
c = &b;
```



## 空指针

- 空指针的类型是一种特殊的指针。在C++中，`void`表示没有类型，因此，空指针表示没有类型的指针(因此，指针的长度也不确定，而解引用属性也不确定)

```c++
void * name;
```



- 其可能的用途之一可能是将通用参数传递给函数。实例：

```c++
#include <iostream>
using namespace std;

void increase (void * data,int psize)
{
    if (psize == sizeof(char))
    {
        char * pchar;
        pchar = (char*)data;
        ++(*pchar);
    }
    else if (pszie == sizeof(int))
    {
        int * pint;
        pint = (int *)data;
        ++(*pint);
    }
    int main()
    {
        char a = 'x';
        int b = 1602;
        increase(&a, sizeof(a));
        increase(&b, sizeof(b));
        cout << a << ',' << b << '\n';
        
        return 0;
    }
}
```



## 无效指针和空指针

- 原则上，指针旨在指向有效地址，例如变量的地址或数组中元素的地址。但是指针实际上可以指向任何地址，包括不引用任何有效元素的地址。

```c++
int arr[10];
int * q = arr + 20;	// 元素越界
```

**既不指向`p`也不`q`包含已知值的地址，但以上语句均未引起错误。在C ++中，无论该地址实际上是否有内容，都允许指针采用任何地址值。可能导致错误的是取消引用此类指针（即，实际上访问它们指向的值）。访问此类指针会导致不确定的行为，从运行时错误到访问某些随机值。**



- 既不指向`p`也不`q`包含已知值的地址，但以上语句均未引起错误。在C ++中，无论该地址实际上是否有内容，都允许指针采用任何地址值。可能导致错误的是取消引用此类指针（即，实际上访问它们指向的值）。访问此类指针会导致不确定的行为，从运行时错误到访问某些随机值。

```c++
int * p = 0;
int * p = nullptr;
```

*在这里，两个都是空指针*



- 在较旧的代码中使用定义的常量来引用空指针值：

```c++
int * p = NULL;
```

<u>**注意，不要把`null pointer`和`void pointer`混淆，`null pointer`指的是任何指针可以采取以表示它指向“无处”，而`void pointer`可以指向某处没有特定类型的。一个引用存储在指针中的值，另一个引用其指向的数据类型。**</u>



## 指向函数的指针

- C ++允许通过函数指针进行操作。此方法的典型用法是将一个函数作为参数传递给另一个函数。函数指针的声明与常规函数声明的语法相同，不同之处在于，函数的名称包含在括号（）之间，并且`*`在名称之前插入星号（）：

```c++
#include <iostream>
using namespace std;

inline int add (int a, int b)
{
    return a + b;
}
inline int sub (int a, int b)
{
    return a - b;
}

int operation (int x, int y, int (*func)(int, int))
{
    return (*func)(x, y);
}

int main()
{
    int m, n;
    int (*minus)(int, int) = sub;
    
    m = operation(7, 5, add);
    n = operation(20, m, minus);
    cout << n;
    return 0;
}
```

