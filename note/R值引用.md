# L值和R值引用



## L值和r值

- 尽管l值和r值的名称中包含“值”一词，但实际上它们不是值的属性，而是表达式的属性。

- C ++中的每个表达式都有两个属性：一个**类型**（用于类型检查）和**值类别**（用于某些类型的语法检查，例如是否可以将表达式的结果分配给它）。

## L值引用

- 在C ++ 11之前，C ++中仅存在一种引用类型，因此它被称为“引用”。但是，在C ++ 11中，有时将其称为`L`值引用。`L`值引用只能用可修改的L值初始化。

| L值引用         | 可以用初始化 | 可以修改 |
| :-------------- | :----------- | :------- |
| 可修改的`L`值   | 是           | 是       |
| 不可修改的`L`值 | 没有         | 没有     |
| R值             | 没有         | 没有     |

- 可以使用l值和r值初始化对`const`对象的L值引用。但是，这些值不能修改

| 引用`const`的L值 | 可以用初始化 | 可以修改 |
| :--------------- | :----------- | :------- |
| 可修改的`L`值    | 是           | 没有     |
| 不可修改的`L`值  | 是           | 没有     |
| R值              | 是           | 没有     |

- 对`const`对象的`L`值引用特别有用，因为它们使我们可以将任何类型的参数（`L`值或`R`值）传递给函数，而无需复制该参数。



## R值引用

- C ++ 11添加了一种称为`R`值引用的新型引用。`R`值引用是设计为使用`R`值初始化的引用（仅）。当使用单个“＆”符号创建左值引用时，使用双“＆”符号创建`R`值引用时：

```c++
int x{1};
int& lref{x};	// L值引用初始化值为x的值
int&& rref{1};	//	R值引用初始化的值为1
```

| `R`值参考       | 可以用初始化 | 可以修改 |
| :-------------- | :----------- | :------- |
| 可修改的`L`值   | 没有         | 没有     |
| 不可修改的`L`值 | 没有         | 没有     |
| `R`值           | 是           | 是       |

| `R`值引用`const` | 可以用初始化 | 可以修改 |
| :--------------- | :----------- | :------- |
| 可修改的`L`值    | 没有         | 没有     |
| 不可修改的`L`值  | 没有         | 没有     |
| `R`值            | 是           | 没有     |

- `R`值引用具有两个有用的属性。首先，`R`值引用将初始化它们的对象的寿命延长到`R`值引用的寿命（对`const`对象的l值引用也可以做到这一点）。其次，非常量`R`值引用使您可以修改`R`值！

```c++
#include <iostream>

class R_val
{
private:
	int m, n;
public:
	R_val(int a, int b) : m{a}, n{b}{}
	friend std::ostream& operator<<(std::ostream& out, const R_val& r)
	{
		return out << r.m << '/' << r.n;
	}
};

int main()
{
	auto &&rref{R_val(2, 3)};
	std::cout << rref;
	return 0;	
}
```



## R值引用作为函数参数

- `R`值引用更经常用作函数参数。当您想对`L`值和`R`值参数具有不同的行为时，这对于函数重载最有用。

```c++
#include <iostream>

// L值引用调用这个函数
void func(const int &l)
{
    std::cout << "l-value" << std::endl;
}

// R值引用调用这个函数
void func(int &&r)
{
    std::cout << "r-value" << std::endl;
}

int main()
{
    int x{10};
    func(x);
    func(10);
    return 0;
}
```



## 返回R值引用

- 出于相同的原因，您几乎永远不应返回r值引用，出于几乎同样的原因，也应永远不要返回l值引用。在大多数情况下，当被引用的对象超出函数结尾的范围时，您最终将返回一个挂起的引用。



**测试**

- 哪些不能成功被编译？

```c++
int main
{
    int value{};
    
    int &ref1{value};	// A
    int &ref2{5};	// B
    
    const int &ref3{value};  // C
    const int &ref4{5};	// D
    
    int &&ref5{value};	// E
    int &&ref6{5};	// F
    
    const int &&ref7{value};	// G
    const int &&ref8{5};	// F
    
    return 0;
}
```

<details><summary><b>展开查看答案</b></summary>
		B、E和G编译失败
</details>
