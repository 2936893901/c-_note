# Dynamic memory

- 所有内存需求都是在程序执行之前通过定义所需变量来确定的。但是在某些情况下，只能在运行时确定程序的内存需求。当何时需要存储空间取决于用户输入。在这些情况下，程序需要动态分配内存，为此C ++语言将运算符`new`和集成在一起`delete`。

****
## `new`运算符和`new[]`

- 动态内存是使用`new`运算符分配的，`new`后面跟一个数据类型说明符，如果需要一个以上的元素序列，则在方括号中将这些元素的数目`[]`

```c++
pointer = new type;
pointer = new type[number];
```

- 第一个表达式用于分配内存以包含一个`type`单个元素。第二个用于分配类型为的元素的块（数组），其中是代表这些元素数量的整数值。



- 我们程序所请求的动态内存是由系统从内存堆中分配的。但是，计算机内存是有限的资源，并且可能会耗尽。因此，不能保证`new`系统将准许所有使用操作符分配内存的请求。



- C ++提供了两种标准机制来检查分配是否成功：

1. 通过处理异常，使用这个方法，当分配失败时抛出类型为`bad_alloc`的异常

2. `nothrow`，当内存分配失败时，`bad_alloc`返回的指针`new`不是`null`指针，而不会引发异常或终止程序，并且程序将继续正常执行。

```c++
name = new (nothrow) type [number];
```

- 在这种情况下，如果此内存块的分配失败，则可以通过检查是否`name`为空指针来检测失败：

```c++
int * foo;
foo = new (nothrow) int [5];
if (foo == nullptr)
{
    //
}
```



**<u>此`nothrow`方法可能产生比异常效率低的代码，因为它意味着显式检查每次分配后返回的指针值。因此，至少对于关键分配，通常优选使用异常机制。尽管如此，`nothrow`由于其简单性，接下来的大多数示例仍将使用该机制。</u>**

****

## `delete`和`delete[]`

- 在大多数情况下，仅在程序内的特定时间段内才需要动态分配的内存。一旦不再需要它，就可以释放它，以便使该内存再次可用于其他动态内存请求。这是运算符`delete`目的，其语法是：

```c++
delete pointer;
delete[] pointer;
```

****

## C中的动态内存

- C ++集成了运算符`new`并`delete`用于分配动态内存。但是这些不是C语言提供的。相反，它使用了库解决方案功能`malloc`，`calloc`，`realloc`和`free`，在报头中定义的`<cstdlib>`（已知为`<stdlib.h>`在C）。这些函数在C ++中也可用，也可以用于分配和取消分配动态内存。



*但是请注意，这些功能分配的内存块不一定与所返回的内存块兼容`new`，因此不应将它们混合使用。每个人都应该使用自己的一组函数或运算符来处理。*