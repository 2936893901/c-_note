# 函数

- 在C ++中，一个函数是一组语句，这些语句被赋予一个名称，可以从程序的某个点进行调用。

```c++
type name (parameter1, parameter2, ...)
{
    statement;
}
```

- `type`:函数返回值的类型。
- `name`:方法名，是函数可以被调用的标识符。
- `parameter`参数
- `statement`:方法执行的语句



*注意：无论定义顺序如何，C ++程序始终都通过调用开头`main`。实际上，`main`是唯一一个自动调用的函数，并且任何其他函数中的代码仅在从`main`（直接或间接）调用其函数时才执行。*



## 无返回值(`void`)



```c++
void name (argument1, argument2, ...)
{
    statement;
}
```



- `void`也可以在函数的参数列表中使用它来明确指定函数在调用时不接受任何实际参数，例如：

```c++
void test (void)
{
    cout << "I`m a function";
}
```



## `main`的返回值

- 当`main`返回零（隐式或显式）时，环境会将其解释为程序成功结束。可能会返回其他值`main`，并且某些环境可以某种方式向调用方提供对该值的访问权限，尽管此行为不是必需的，也不一定在平台之间可移植。

| 值                       | 描述                                                   |
| ------------------------ | ------------------------------------------------------ |
| `return` 0;              | 程序成功                                               |
| `return` `EXIT_SUCCESS`; | 程序成功（和上面一样）,这个值需要定义头文件`<cstdlib>` |
| `return` `EXIT_FAILURE`; | 程序失败，这个值需要定义一个头文件`<cstdlib>`          |



## 通过值和引用传递的参数

- 在调用函数时，传递给函数的是这些参数在调用时的值，这些参数的值将被复制到由函数参数表示的变量中。

- 在函数内对这些变量的任何修改都不会影响其外部的变量的值
- 为了访问其参数，该函数将其参数声明为*reference*。在C ++中，引用与`&`参数类型后面的符号（＆）一样，例如：

```c++
void name (int& x, int& y)
{
    x++;
    y++;
}
```



## 效率注意事项和`const`参考

- 调用带有值所带参数的函数会导致复制值。对于诸如的基本类型，这是相对便宜的操作`int`，但是如果参数属于大型复合类型，则可能会导致一定的开销。例如：

```c++
string concatenate (string a, string b)
{
	return a + b;
}
```

- 此函数将两个字符串作为参数（按值），并返回将它们串联的结果。通过按值传递的参数，功能势力`a`和`b`被传递给函数的参数的拷贝，当它被调用。如果它们是长字符串，则可能意味着仅为了函数调用而复制大量数据。



- 如果两个参数都被*引用，*则可以完全避免使用此副本：

```c++
string concatenate (string& a, string& b)
{
	return a + b;
}
```



- 该功能的解决方案是确保该功能不会修改其参考参数。这可以通过将参数限定为常量来完成：

```c++
string concatenate (const string& a, const string& b)
{
    return a + b;
}
```



*`const`引用提供的功能类似于按值传递参数，但是对大型类型的参数具有更高的效率。这就是为什么它们在C ++中非常流行用于复合类型的参数的原因。但是请注意，对于大多数基本类型，效率没有明显的区别，在某些情况下，`const`引用的效率甚至可能更低！*



## 内联函数

- 调用函数通常会导致一定的开销（堆叠参数，跳转等），因此对于非常短的函数，将函数的代码简单地插入到被调用的位置而不是执行处理可能会更有效。
- 在带有说明`inline`符的函数声明之前，会通知编译器，对于特定功能，内联扩展优于常规函数调用机制。这根本不会改变函数的行为，而只是用于建议编译器，由函数主体生成的代码应在调用函数的每个点插入，而不是通过常规函数调用来调用。

```c++
inline string concatenate (const string& a, const string& b)
{
    return a + b;
}
```

- 即使不使用内联修饰符，类定义中的函数定义也是内联函数定义。

## 参数的默认值

- 在C ++中，函数还可以具有可选参数，在调用中不需要参数，例如，可以仅用两个调用具有三个参数的函数。为此，函数应为其最后一个参数包括一个默认值，该函数在调用较少参数时将由函数使用。

```c++
int divide (int a, int b = 2)
{
    return a / b;
}
```



## 声明方法

- 声明应包括所有涉及的类型（返回类型及其参数的类型），使用与函数定义中相同的语法，但用结尾的分号代替函数的主体（语句块）。
- 参数列表不需要包括参数名称，而只需包括它们的类型。虽然可以指定参数名称，但是参数名称是可选的，不需要与函数定义中的参数名称匹配。

```c++
int protofunction (int x);

int protofunction (int x)
{
    return x;
}
```



## 递归

- 递归是必须自己调用函数的属性。它对某些任务（例如排序元素或计算数字的阶乘）很有用。